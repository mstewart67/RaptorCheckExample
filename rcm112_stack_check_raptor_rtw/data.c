/*****************************************************************************
   data.c
   Generated By:
   Raptor 2023b_1.0.0 (9999_9999)
   Matlab (R2023a) 9.14

   Copyright (c) 2024 New Eagle Products, Inc.
   All rights reserved.

   Code Generated at: Wed Mar 27 13:31:34 2024
 *****************************************************************************/

#include "raptor_types.h"
#include "data.h"
#include "string.h"                    /* TODO Reseach availabilty */
#include "rcm112_stack_check.h"
#include "rcm112_stack_check_private.h"
#include "Std_Types.h"
#include "interface.h"

/* SS_DOUBLE  =  0,    / real32_T    /
   SS_SINGLE  =  1,    / real32_T  /
   SS_INT8    =  2,    / int8_T    /
   SS_UINT8   =  3,    / uint8_T   /
   SS_INT16   =  4,    / int16_T   /
   SS_UINT16  =  5,    / uint16_T  /
   SS_INT32   =  6,    / int32_T   /
   SS_UINT32  =  7,    / uint32_T  /
   SS_BOOLEAN =  8     / boolean_T */
RAMVariables_T RAMVariables __attribute__ ((section(".mc0_ram")));
const RAMVariables_T RAMVariables_DEFAULT __attribute__ ((section(".romcals"))) =
{
  55,                                  /*INIT_RAM_Variables*/
  0,                                   /* FgndTasksStopped */
  0,                                   /* CANWakeIndicator */
  0,                                   /* EthWakeIndicator */
  0,                                   /* EthLinkStatus */
  0,                                   /* LINWakeIndicator */
  0UL,                                 /* Wake_CAN5_RxCount */
  0UL,                                 /* Wake_CAN5_SleepDelayTTmr */
  0UL,                                 /* Wake_ETH_SleepDelayTTmr */
  0UL,                                 /* Wake_LIN2_SleepDelayTTmr */
  0,                                   /* KeySw_Bgnd */
  0,                                   /* KeepModuleOn */
  0,                                   /* MPRD_EN */
  0U,                                  /* Wake_Source */
  0,                                   /* Counter */
  11UL,                                /* EcuAddr_RAM */
  1539UL,                              /* UDSServerAddr_RAM */
  1619UL,                              /* UDSClientAddr_RAM */
  0U,                                  /* EEPROM_State */
};

void initRAMVariables(RAMVariables_T* ramVariables)
{
  memcpy(ramVariables, &RAMVariables_DEFAULT, sizeof(RAMVariables_DEFAULT));
}

const CONSTVariables_T CONSTVariables __attribute__ ((section(".romcals"))) = {
  { 114U, 99U, 109U, 49U, 49U, 50U, 95U, 115U, 116U, 97U, 99U, 107U, 95U, 99U,
    104U, 101U, 99U, 107U, },          /* ModelName */
  19UL,                                /* BuildNumber */

  { 40U, 82U, 50U, 48U, 50U, 51U, 97U, 41U, 32U, 57U, 46U, 49U, 52U, },/* MatlabVersion */

  { 50U, 48U, 50U, 51U, 98U, 95U, 49U, 46U, 48U, 46U, 48U, 95U, 57U, 57U, 57U,
    57U, 95U, 57U, 57U, 57U, 57U, },   /* RaptorVersion */

  { 114U, 99U, 109U, 49U, 49U, 50U, 95U, 115U, 116U, 97U, 99U, 107U, 95U, 99U,
    104U, 101U, 99U, 107U, 95U, 48U, 49U, 57U, },/* SwIdTxt */

  { 114U, 99U, 109U, 49U, 49U, 50U, 95U, 115U, 116U, 97U, 99U, 107U, 95U, 99U,
    104U, 101U, 99U, 107U, 95U, 48U, 49U, 57U, 95U, 48U, 48U, 48U, },/* CalIdTxt */

  { 99U, 72U, 115U, 110U, 105U, 81U, 52U, 66U, 70U, 107U, 75U, 76U, 73U, 70U,
    100U, 66U, 85U, 67U, 52U, 50U, 79U, },/* BuildUID */
  4,                                   /* IdTableRev */
  18875138UL,                          /* HardwareType */

  { 50U, 55U, 45U, 77U, 97U, 114U, 45U, 50U, 48U, 50U, 52U, 32U, 49U, 51U, 58U,
    51U, 49U, 58U, 51U, 52U, },        /* DateStamp */
};

void initCONSTVariables(const CONSTVariables_T* cv)
{

#ifdef UNUSED

  UNUSED(cv);

#endif

}

/* Total EEPROM Structure Size: 41U Bytes */
const EEVariables_T EEVariables_DEFAULT __attribute__ ((section(".ee_default")))
  =
{
  1419688852U,                         /* EE_UniqID 	*/
  1200UL,                              /* Wake_CAN5_SleepDelayTime */
  1200UL,                              /* Wake_ETH_SleepDelayTime */
  1200UL,                              /* Wake_LIN2_SleepDelayTime */
  0.2F,                                /* KeySwHiTimeThr */
  0.2F,                                /* KeySwLoTimeThr */
  0U,                                  /* SensorPowerEnable */
  256UL,                               /* XCP1__XCP_BC_ID */
  512UL,                               /* XCP1__XCP_RX_ID */
  768UL,                               /* XCP1__XCP_TX_ID */
  20037U,                              /* XCP1__XCP_Security */
  0,                                   /* CRC Initial Value */
};

EEVariables_T EEVariables_RAMShadow __attribute__ ((section(".ee_ram_mc0"))) ;

#define EE_PAGE_SIZE                   120
#define FEE_SIZE_CALC()                (((uint32_T)&FEEVariables_RAMShadow.CRC - (uint32_T)&FEEVariables_RAMShadow) + 2)
#define EE_SIZE_CALC()                 (((uint32_T)&EEVariables_RAMShadow.CRC - (uint32_T)&EEVariables_RAMShadow) + 2)
#define FEE_NUM_PAGES                  10

uint16 read_eeprom(void);
void App_EE_WriteAsync(uint8 param);
extern uint8 g_EEWrite_Requested;
boolean g_feeWrite_Started = 0;
uint8 eeAccessBuf[EE_PAGE_SIZE] = { 0 };

/* MANAGE EE PROM MEMORY */
void App_EE_Defaults(void)
{
  memcpy(&EEVariables_RAMShadow, &EEVariables_DEFAULT, sizeof(EEVariables_T));
  EEPROM_State_Data() = EE_LOADED_DEFAULTS;
}

void App_EE_Init(void);
void App_EE_Init(void)
{
  tBiosFeeState status;
  uint16 ret = 0;
  uint8 firstStart = 0;
  uint32 ee_size = EE_SIZE_CALC();
  status = Bios_Fee_Open();
  if (status != BIOS_FEE_NO_ERROR) {
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_FAILED_DRV_INIT;
    return;
  }

  firstStart = Bios_Fee_Page0.FirstStartFlag;

  /* Fixed NV Read */
  if (firstStart) {
    /* Load defaults after programming - new values may have been merged into EEVariables_DEFAULT */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_AFTER_PROGRAMMING;
  } else if (read_eeprom() != BIOS_FEE_SUCCEEDED) {
    /* Revert to defaults - error reading stored data */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_ERROR_READING;
  } else if (EEVariables_RAMShadow.EE_UniqID != EEVariables_DEFAULT.EE_UniqID) {
    /* Revert to defaults - the data stored previously doesn't match the format for the current application */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_INCORRECT_EEID;
  } else if (!Bios_is_crc_valid((void*)&EEVariables_RAMShadow, (ee_size -2) ,
              EEVariables_RAMShadow.CRC)) {
    /* Revert to defaults - stored data is corrupted */
    App_EE_Defaults();
    EEPROM_State_Data() = EE_LOADED_DEFAULTS_INCORRECT_CRC;
  } else {
    /* Normal case startup, reloaded values */
    EEPROM_State_Data() = EE_LOADED_SAVED_VALUES;
                                      /* Normal case startup, reloaded values */
  }
}

void App_EE_Store(void)
{
  g_EEWrite_Requested = 1;
}

uint16 read_eeprom(void)
{
  tBiosFeeReturnType result;
  uint32 ee_size = EE_SIZE_CALC();
  uint16 total_EE_PgCnt = ee_size/EE_PAGE_SIZE + ((ee_size % EE_PAGE_SIZE) > 0);
  uint16 eeReadIdx = 11;
  uint8* wrPtr = (uint8*)&EEVariables_RAMShadow;
  uint16 lastPageIdx = total_EE_PgCnt + eeReadIdx;
  uint16 lastFullpageIndx = lastPageIdx - 1;
  if ((EE_SIZE_CALC() % EE_PAGE_SIZE) == 0) {
    lastFullpageIndx = lastPageIdx;
  } else {
    lastFullpageIndx = lastPageIdx - 1;
  }

  /* READ Full EEPROM */
  for (; eeReadIdx < lastPageIdx; eeReadIdx++) {
    result = Bios_Fee_ReadNvData(eeReadIdx, (void*)&eeAccessBuf, EE_PAGE_SIZE);
    if (result == BIOS_FEE_SUCCEEDED) {
      if (eeReadIdx < lastFullpageIndx) {
        memcpy(wrPtr, &eeAccessBuf, EE_PAGE_SIZE);
        wrPtr += EE_PAGE_SIZE;
      } else {
        uint8 ee_ReadLen = ee_size % EE_PAGE_SIZE;
        if (ee_ReadLen == 0) {
          ee_ReadLen = EE_PAGE_SIZE;
        }

        memcpy(wrPtr, &eeAccessBuf, ee_ReadLen);
      }
    } else {
      break;
    }
  }

  return result;
}

void App_EE_WriteAsync(uint8 startWrite)
{
  static uint32 ee_size = 0;
  static uint16 total_EE_PgCnt = 0;
  static boolean eeWrite_Started = 0;
  static uint8* eeWrite_Ptr;
  static uint16 eeWrite_Idx = 20;
  static uint16 runningCRC = 0xFFFF;
  static uint32 ee_WriteLen = 0;
  static uint16 lastPageIdx = 0;
  uint8 writeBuffer[EEE_PAGE_SIZE] = { 0 };

  tBiosFeeReturnType result;

  //only execute if we are starting a write or already have one in progress
  if (!startWrite && !eeWrite_Started) {
    return;
  }

  if (!eeWrite_Started) {
    eeWrite_Ptr = (void*)&EEVariables_RAMShadow;
    EEPROM_State_Data() = EE_STORE_IN_PROGESS;
    ee_size = EE_SIZE_CALC();
    total_EE_PgCnt = (ee_size / EE_PAGE_SIZE) + ((ee_size % EE_PAGE_SIZE) > 0);
    eeWrite_Started = 1;
    eeWrite_Idx = 11;
    ee_WriteLen = EE_PAGE_SIZE;
    lastPageIdx = total_EE_PgCnt + eeWrite_Idx - 1;
    runningCRC = 0xFFFF;

    /* Set FirstStartFlag */
    if (Bios_Fee_Page0.FirstStartFlag) {
      Bios_Fee_Page0.FirstStartFlag = 0;
      Bios_Fee_Page0.Fill = 0x0000;
      memcpy(&writeBuffer, &Bios_Fee_Page0, sizeof(tBiosFeePage0));
      result = Bios_Fee_WriteNvData(0, &writeBuffer, EE_PAGE_SIZE);
    }

    if (total_EE_PgCnt == 1) {
      //EE is a single page
      ee_WriteLen = ee_size;
      runningCRC = Bios_crc16_calculation((void*)&EEVariables_RAMShadow,
        ee_WriteLen-2, runningCRC);
      EEVariables_RAMShadow.CRC = runningCRC;
      memcpy((void*)&eeAccessBuf, eeWrite_Ptr, ee_WriteLen);
      result = Bios_Fee_WriteNvData(eeWrite_Idx, (void*)&eeAccessBuf,
        EE_PAGE_SIZE);
      if (result != BIOS_FEE_SUCCEEDED) {
        /* Abort Operation/Failed */
        EEPROM_State_Data() = EE_STORE_FAILED;
        eeWrite_Started = 0;
      } else {
        EEPROM_State_Data() = EE_STORE_SUCCESS;
        eeWrite_Started = 0;
      }
    } else {
      memcpy((void*)&eeAccessBuf, eeWrite_Ptr, ee_WriteLen);
      runningCRC = Bios_crc16_calculation((void*)&eeAccessBuf, ee_WriteLen,
        runningCRC);
      result = Bios_Fee_WriteNvData(eeWrite_Idx, (void*)&eeAccessBuf,
        EE_PAGE_SIZE);
    }
  } else {
    eeWrite_Idx++;
    eeWrite_Ptr += EE_PAGE_SIZE;
    if (eeWrite_Idx == lastPageIdx ) {
      ee_WriteLen = ee_size % EE_PAGE_SIZE;
      if (ee_WriteLen == 0) {
        ee_WriteLen = EE_PAGE_SIZE;
      }

      runningCRC = Bios_crc16_calculation((void*)eeWrite_Ptr, ee_WriteLen-2,
        runningCRC);
      EEVariables_RAMShadow.CRC = runningCRC;
      memcpy((void*)&eeAccessBuf, (void*)eeWrite_Ptr, ee_WriteLen);
      eeWrite_Started = 0;
    } else if (eeWrite_Idx < lastPageIdx) {
      memcpy((void*)&eeAccessBuf, eeWrite_Ptr, ee_WriteLen);
      runningCRC = Bios_crc16_calculation((void*)&eeAccessBuf, ee_WriteLen,
        runningCRC);
    } else {
      /* Finished */
    }

    result = Bios_Fee_WriteNvData(eeWrite_Idx, (void*)&eeAccessBuf, EE_PAGE_SIZE);
    if (result != BIOS_FEE_SUCCEEDED) {
      /* Abort Operation/Failed */
      EEPROM_State_Data() = EE_STORE_FAILED;
      eeWrite_Started = 0;
    } else if (eeWrite_Started == 0) {
      EEPROM_State_Data() = EE_STORE_SUCCESS;
    }
  }
}
